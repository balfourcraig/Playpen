<!DOCTYPE html>
<html lang="en-nz">
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta charset="UTF-8">
	<title>Line Star - Craig's Playpen</title>
	<link rel="stylesheet" href="../css/styles.css">
	<link rel="shortcut icon" type="image/x-icon" href="../favicon.ico" />
	<script>
		function getRandomInt(min, max) {
			min = Math.ceil(min);
			max = Math.floor(max);
			return Math.floor(Math.random() * (max - min + 1)) + min;
		}
		

		function goldenRand(sat, light){
			randh += golden_ratio;
			randh %= 1;
			
			//let sat = getRandomInt(minSat, maxSat);
			//let light = getRandomInt(minLight, maxLight);
			
			return 'hsl(' + (randh * 360) + ', ' + sat + '%, ' + light + '%)';
		}
		
		function gcd(a, b){
			if(b == 0)
				return a;
			else
				return gcd(b, a % b);
		}

		let randh = Math.random();
		const golden_ratio= 0.618033988749895;
		let animationID = null;

		function drawPattern(){
			document.getElementById('drawBtn').setAttribute('style','display:none');
			document.getElementById('stopDrawingBtn').removeAttribute('style');
			
			window.cancelAnimationFrame(animationID);
			const c = document.createElement('canvas');
			const w = document.getElementById('sizeCalc').getBoundingClientRect().width;
			c.setAttribute('width', w);
			c.setAttribute('height', w);
			const ctx = c.getContext('2d');
			const center = {x: w/2.0, y: w/2.0};
			const radius = w * 0.45;
			
			const canvResult = document.getElementById('canvResult');
			canvResult.innerHTML = '';
			canvResult.appendChild(c);
			
			ctx.lineWidth = 1;
			ctx.fillStyle = 'white';
			ctx.strokeStyle = 'none';
			ctx.beginPath();
			ctx.rect(0, 0, w, w);
			ctx.fill();
			
			
			const animate = document.getElementById('animateInput').checked;
			const useColor = document.getElementById('colorInput').checked;
			const blendMode = document.getElementById('blendModeSelect').value;


			const subdivisions = parseInt(document.getElementById('subInput').value);
			const points = 8;
			const skip = 3;
			const drawings = [];
			
			ctx.globalCompositeOperation = blendMode;
			
			let spokes = [];
			
			const cardinalColor = useColor ? goldenRand(75,50) : 'black';
			const subCardinalColor = useColor ? goldenRand(75,50) : 'black';
			const northColor = useColor ? goldenRand(75,50) : 'black';

			const colors = [
				cardinalColor,//S
				subCardinalColor,//SE
				cardinalColor,//E
				subCardinalColor,//NE
				northColor,//N
				subCardinalColor,//NW
				cardinalColor,//W
				subCardinalColor//SW
			];
			
			const cardinalLength = 0.6;
			const subCardinalLength = 0.35;
			const northLength = 0.9;
			const spokeLengths = [
				cardinalLength,//S
				subCardinalLength,//SE
				cardinalLength,//E
				subCardinalLength,//NE
				northLength,//N
				subCardinalLength,//NW
				cardinalLength,//W
				subCardinalLength//SW
			];
			
			drawings.push(() => drawCircle(ctx, center, radius * 0.3, colors[1]));
			drawings.push(() => ctx.globalAlpha = 0.7);
			for(let i = 0; i < 8; i++){
				const p1 = pointOnCircle(center, w, points * 2, i, 0);
				const p2 = pointOnCircle(center, w, points * 2, i + 8, 0);
				
				drawings.push(() => drawLineFlat(ctx, p1, p2, colors[(i + 1) % 4]));
			}
			
			drawings.push(() => ctx.globalAlpha = 1);
			
			for(let i = 0; i < points; i++){
				if(!useColor)
					colors[i] = 'black';
				spokes.push([]);
				spokes[i][0] = pointOnCircle(center, radius * spokeLengths[i], points, i, 0);
				
				for(let j = 1; j < subdivisions; j++){
					spokes[i][j] = subdivideLine(spokes[i][0], center, subdivisions, j);
				}
			}
			
			const shift = skip % points;
			const divisor = gcd(skip, points) - 1;

			for(let p = 0; p < points * skip; p += skip){
				let i = (p + (divisor * ~~(p/points))) % points;//this is tempremental af, do not touch it unless you want to spend hours of pain
				if(p !== 0 && i === 0)
					i++;

				drawings.push(() => drawLineFlat(ctx, spokes[i][0], center, colors[i]));
					
				for(let j = 0; j < subdivisions; j++){
					if(useColor){
						drawings.push(() => drawLineGradient(ctx, spokes[i][j], spokes[(i + skip) % points][subdivisions-1-j], colors[i], colors[(i + skip) % points]));
					}
					else{
						drawings.push(() => drawLineFlat(ctx, spokes[i][j], spokes[(i + skip) % points][subdivisions-1-j], colors[i]));
					}
				}
			}
			
			const cardinalDirections = ['S','E','N','W'];
			const fontSize = ~~(w / 20);
			
			ctx.font = fontSize + 'px Arial';
			ctx.textAlign = "center";
			drawings.push(() => {ctx.globalCompositeOperation = 'source-over';});
			for(let i = 0; i < 4; i++){
				drawings.push(() => ctx.fillStyle = colors[i*2]);
				const p = pointOnCircle(center, radius * spokeLengths[i * 2] + fontSize, 4, i, 0);
				drawings.push(() => ctx.fillText(cardinalDirections[i], p.x, i % 2 == 0 ? p.y : p.y + fontSize *0.35));
			}
			
			if(animate){
				animateLine(drawings, 0);
			}
			else{
				for(let i = 0; i < drawings.length; i++){
					drawings[i]();
				}
			}

			document.getElementById('drawBtn').removeAttribute('style');
			document.getElementById('stopDrawingBtn').setAttribute('style','display:none');
		}
		
		function drawLineGradient(ctx, start, end, colorFrom, colorTo){
			const grad = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
			grad.addColorStop(0, colorFrom);
			grad.addColorStop(1, colorTo);
			ctx.strokeStyle = grad;

			ctx.beginPath();
			ctx.moveTo(start.x, start.y);
			ctx.lineTo(end.x,end.y);
			ctx.stroke();
		}
		
		function subdivideLine(p1, p2, totalSegments, seg){
			const xDiff = p2.x - p1.x;
			const yDiff = p2.y - p1.y;
			
			const ratio = (1/totalSegments) * seg;
			
			const x = xDiff * ratio + p1.x;
			const y = yDiff * ratio + p1.y;
			
			return {x:x, y:y};
		}
		
		function pointOnCircle(center, radius, totalPoints, pointNum, rotation){
			const angle = (pointNum / totalPoints * Math.PI * 2) + rotation;
			const x = Math.sin(angle) * radius + center.x;
			const y = Math.cos(angle) * radius + center.y;
			return {x:x, y:y};
		}
		
		function drawLineFlat(ctx, start, end, color){
			ctx.strokeStyle = color;
			ctx.beginPath();
			ctx.moveTo(start.x, start.y);
			ctx.lineTo(end.x,end.y);
			ctx.stroke();
		}
		
		function drawCircle(ctx, center, radius, color){
			ctx.strokeStyle = color;
			ctx.beginPath();
			ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
			ctx.stroke();
		}
		
		function animateLine(allActions, index){
			if(index < allActions.length){
				allActions[index]();
				animationID = window.requestAnimationFrame(() => {
					animateLine(allActions, index + 1);
				});
			}
			else{
				document.getElementById('drawBtn').removeAttribute('style');
				document.getElementById('stopDrawingBtn').setAttribute('style','display:none');
			}
		}

		window.addEventListener('DOMContentLoaded', () => {
			document.getElementById('drawBtn').addEventListener('click', drawPattern);
			document.getElementById('stopDrawingBtn').addEventListener('click', () => {
				cancelAnimationFrame(animationID);
				document.getElementById('stopDrawingBtn').setAttribute('style','display:none');
				document.getElementById('drawBtn').removeAttribute('style');
			});
		});
	</script>
	
</head>
<body>
<div class="navHolder">
	<nav>
		<a href="../index.html">Home</a>
		<a class="selected" href="../ramblings.html">Deranged Ramblings</a>
		<a href="../about.html">About</a>
	</nav>
</div>

<main>
	<div class="pageWidth">
		<header>
			<h1>Line Star</h1>
		</header>
		<section>
			<p>This is pretty broken really, many combinations don't work or only partially draw or redraw parts.</p>
			<input id="animateInput" type="checkbox" checked>
			<label for="animateInput">Animate</label>
			<br>
			<input id="colorInput" type="checkbox" checked>
			<label for="colorInput">Use color</label>
			<br>
			<select id="blendModeSelect">
				<option value="source-over">Source Over (Default)</option>
				<option value="multiply" selected>Multiply</option>
				<option value="darken">Darken</option>
			</select>
			<label for="blendModeSelect">Blend Mode</label>
			<br>
			<input id="subInput" type="number" min="0" value="17">
			<label for="subInput">Number of segments on each point</label>
			<br>
			<button id="drawBtn">Draw!</button>
			<button id="stopDrawingBtn" style="display:none">STOP</button>

			<div id="sizeCalc"></div>
			<img id="modMulResult">
			<div id="canvResult"></div>
		</section>
		<div class="scrollOverflow"></div>
	</div>
</main>
</body>
</html>