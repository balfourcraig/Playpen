<!DOCTYPE html>
<html lang="en-nz">
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta charset="UTF-8">
	<title>Personal Pattern - Craig's Playpen</title>
	<link rel="stylesheet" href="../css/styles.css">
	<script src="../scripts/utils.js"></script>
	<script>
		let animationID = null;

		function getUrlVars() {
			var vars = {};
			var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m,key,value) {
				vars[key] = value;
			});
			return vars;
		}
		
		function drawLine(ctx, center, radius, multiplier, points, i, iterations, useColor, color, useGradient){
			if(iterations > 0){
				const pointFrom = pointOnCircle(center, radius, points, i % points);
				const pointTo = pointOnCircle(center, radius, points, (i * multiplier) % points);
				
				if(useColor){
					const grad = ctx.createLinearGradient(pointFrom.x, pointFrom.y, pointTo.x, pointTo.y);
					if(useGradient){
						const iFrom = ((i % points)/points) * 360;
						const iTo = (((i * multiplier) % points)/points) * 360;
						grad.addColorStop(0, 'transparent');
						grad.addColorStop(0.4, 'hsl(' + iFrom + ', 80%, 50%)');
						grad.addColorStop(0.6, 'hsl(' + iTo + ', 80%, 50%)');
						grad.addColorStop(1, 'transparent');
					}
					else{
						grad.addColorStop(0, 'transparent');
						grad.addColorStop(0.5, color);
						grad.addColorStop(1, 'transparent');
					}
					ctx.strokeStyle = grad;
				}

				ctx.beginPath();
				ctx.moveTo(pointFrom.x, pointFrom.y);
				ctx.lineTo(pointTo.x, pointTo.y);
				ctx.stroke();
				
				animationID = window.requestAnimationFrame(() =>{
					drawLine(ctx, center, radius,multiplier, points, i+1, iterations -1, useColor, color, useGradient);
				});
			}
			else{
				document.getElementById('drawBtn').removeAttribute('style');
				document.getElementById('stopDrawingBtn').setAttribute('style','display:none');
			}
		}
		
		function drawModMul(){
			let name = document.getElementById('nameInput').value;
			if(!name)
				return;
			
			name = name.toUpperCase();
			
			document.getElementById('drawBtn').setAttribute('style','display:none');
			document.getElementById('stopDrawingBtn').removeAttribute('style');
			
			window.cancelAnimationFrame(animationID);
			const c = document.createElement('canvas');
			const w = document.getElementById('sizeCalc').getBoundingClientRect().width;
			c.setAttribute('width', w);
			c.setAttribute('height', w);
			const ctx = c.getContext('2d');
			ctx.globalAlpha = 0.6;
			ctx.lineWidth = 1;
			const center = {x: w/2.0, y: w/2.0};
			const radius = w * 0.45;
			ctx.globalCompositeOperation = 'multiply';
			const canvResult = document.getElementById('canvResult');
			canvResult.innerHTML = '';
			canvResult.appendChild(c);
			
			ctx.fillStyle = 'white';
			ctx.strokeStyle = 'black';
			ctx.beginPath();
			ctx.rect(0, 0, w, w);
			ctx.fill();

			let multiplier = Math.floor(stringHash(name, 7) * 100 + 2);
			const points = Math.floor(stringHash(name, 17) * 800 + 200);
			
			let iterations = points;
			let winding = Math.floor(stringHash(name, 53) * 4 + 1);
			if(winding && winding > 1){
				iterations *= winding;
				multiplier += (1 / winding);
			}
			
			const color = randomColor();
			
			const animate = document.getElementById('animateInput').checked;
			
			const useColor = true;
			const useGradient = true;

			if(animate){
				drawLine(ctx, center, radius, multiplier, points, 0, iterations, useColor, color, useGradient);
			}
			else{
				for(let i = 1; i < iterations; i++){
					const pointFrom = pointOnCircle(center, radius, points, i % points);
					const pointTo = pointOnCircle(center, radius, points, (i * multiplier) % points);
					if(useColor){
						const grad = ctx.createLinearGradient(pointFrom.x, pointFrom.y, pointTo.x, pointTo.y);
						
						const iFrom = ((i % points)/points) * 360;
						const iTo = (((i * multiplier) % points)/points) * 360;
						grad.addColorStop(0, 'transparent');
						grad.addColorStop(0.4, 'hsl(' + iFrom + ', 80%, 50%)');
						grad.addColorStop(0.6, 'hsl(' + iTo + ', 80%, 50%)');
						grad.addColorStop(1, 'transparent');

						ctx.strokeStyle = grad;
					}
					
					ctx.beginPath();
					ctx.moveTo(pointFrom.x, pointFrom.y);
					ctx.lineTo(pointTo.x, pointTo.y);
					ctx.stroke();
				}
				document.getElementById('drawBtn').removeAttribute('style');
				document.getElementById('stopDrawingBtn').setAttribute('style','display:none');
			}
		}
		
		function copyShareLink(){
			const area = document.createElement('textarea');
			const input = document.getElementById('nameInput').value ? '?input=' + document.getElementById('nameInput').value : '';
			area.value = location.protocol + '//' + location.host + location.pathname + input;
			document.body.appendChild(area);
			area.select();
			document.execCommand('copy');
			document.body.removeChild(area);
			alert('link copied');
		}

		function updateButtonEnabled(){
			if(document.getElementById('nameInput').value){
				document.getElementById('drawBtn').removeAttribute('disabled');
				document.getElementById('copyBtn').removeAttribute('disabled');
			}
			else{
				document.getElementById('drawBtn').setAttribute('disabled','disabled');
				document.getElementById('copyBtn').setAttribute('disabled','disabled');
			}
		}
		
		window.addEventListener('DOMContentLoaded', () => {
			document.getElementById('drawBtn').addEventListener('click', drawModMul);
			document.getElementById('stopDrawingBtn').addEventListener('click', () => {
				cancelAnimationFrame(animationID);
				document.getElementById('stopDrawingBtn').setAttribute('style','display:none');
				document.getElementById('drawBtn').removeAttribute('style');
			});
			document.getElementById('nameInput').addEventListener('input', updateButtonEnabled);
			document.getElementById('nameInput').addEventListener('keyup', (e) => {
				if (e.keyCode === 13) {
					e.preventDefault();
					drawModMul();
				}
			});
			document.getElementById('copyBtn').addEventListener('click', copyShareLink);
			
			const urls = getUrlVars();
			
			if(urls['input']){
				document.getElementById('nameInput').value = decodeURIComponent(urls['input']);
				drawModMul();
			}
			updateButtonEnabled();
		});
	</script>
	<link rel="shortcut icon" type="image/x-icon" href="../favicon.ico" />
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-160042243-1"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'UA-160042243-1');
	</script>
</head>
<body>
<div class="navHolder">
	<nav>
		<a href="../index.html">Home</a>
		<a class="selected" href="../ramblings.html">Deranged Ramblings</a>
		<a href="../about.html">About</a>
	</nav>
</div>
<main>
	<div class="pageWidth">
		<header>
			<h1>Personal Pattern</h1>
		</header>
		<section>
			<p>Input any name or text and click draw to see its unique fingerprint pattern</p>
			<div class="optionsArea">
				<div class="nameArea">
					<input id="nameInput" type="text" placeholder="Name">
				</div>
				<div class="op">
					<input id="animateInput" type="checkbox">
					<label for="animateInput">Animate</label>
				</div>
			</div>
			<div class="optionsArea">
				<div class="op">
					<button id="drawBtn">Draw!</button>
					<button id="stopDrawingBtn" style="display:none">STOP</button>
					<br>
					<button id="copyBtn" title="Copy to clipboard a permalink to the current settings">Copy Shareable Link</button>
				</div>
			</div>
			<div id="sizeCalc"></div>
			<div id="canvResult"></div>
		</section>
		<div class="scrollOverflow"></div>
	</div>
</main>
</body>
</html>