<!DOCTYPE html>
<html lang="en-nz">
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta charset="UTF-8">
	<title>Theramin - Craig's Playpen</title>
	<link rel="stylesheet" href="../css/styles.css">
	<link rel="shortcut icon" type="image/x-icon" href="../favicon.ico" />
	<script>
		const golden_ratio= 0.618033988749895;
		let randh = Math.random();
		let w = 0;
		let osc;
		let gainNode;
		let mousePosArr = [];
		let started = false;
		const mousePositions = 100;
		
		function nextGoldenRand(){
			randh += golden_ratio;
			randh %= 1;
			return randh;
		}
		
		function nextGoldenColor(sat, light){
			const num = nextGoldenRand();
			return 'hsl(' + (num * 360) + ', ' + sat + '%, ' + light + '%)';
		}

		function randomColor() {
			var letters = '0123456789ABC';
			var color = '#';
			for (var i = 0; i < 6; i++) {
				color += letters[Math.floor(Math.random() * letters.length)];
			}
			return color;
		}
		
		function shuffleInplace(arr){
			let n = arr.length;
			while(n > 0){
				const r = Math.floor(Math.random() * n);
				const temp = arr[r];
				arr[r] = arr[n-1];
				arr[n-1] = temp;
				n--;
			}
		}
		
		const goldenAngleRad = 2.39996322972865332;
		let ctx;
		
		function setUp(){
			started = true;
			w = document.getElementById('sizeCalc').getBoundingClientRect().width;
			console.log('setup');
			const c = document.createElement('canvas');
			c.id = 'pieCanvas';
			c.setAttribute('width', w);
			c.setAttribute('height', w);
			ctx = c.getContext('2d');
			const canvResult = document.getElementById('canvResult');
			canvResult.innerHTML = '';
			canvResult.appendChild(c);
			
			mousePosArr = [];
			const aCtx = new AudioContext(); 
			
			gainNode = aCtx.createGain();
			gainNode.gain.value = 0.3;
			gainNode.connect(aCtx.destination);
			

			osc = aCtx.createOscillator();
			osc.frequency.value = 0;
			osc.type = 'sine';
			osc.connect(gainNode);
			osc.start();
			
			canvResult.addEventListener('mousemove', drawPattern);
			canvResult.addEventListener('touchmove', drawPattern);
			
			document.getElementById('startBtn').style.display = 'none';
			document.getElementById('stopDrawingBtn').style.display = 'block';
			drawPattern();
		}

		function drawPattern(e){
			if(started){
				ctx.strokeStyle = 'black';
				const c = document.getElementById('pieCanvas');
				ctx.clearRect(0,0,w,w);
				ctx.strokeRect(0,0,w,w);
				
				const rect = c.getBoundingClientRect();

				if(e) {
					const mouseX = e.clientX - rect.left;
					const mouseY = e.clientY - rect.top;
					
					const xMapped = (0.9 * Math.pow(mouseX / rect.width, 1.5)) + 0.1;
					const yMapped = mouseY / rect.height;

					
					osc.frequency.value = xMapped * 1000;
					gainNode.gain.value = yMapped;
					const mousePoint = {x:mouseX, y:mouseY};
					
					if(mousePosArr.length < mousePositions){
						mousePosArr.unshift(mousePoint);
					}
					else{
						for(let i = mousePosArr.length -1; i > 0; i--){
						console.log(i);
							mousePosArr[i] = mousePosArr[i-1];
						}
						mousePosArr[0] = mousePoint;
					}
					console.log(JSON.stringify(mousePosArr));
					if(mousePosArr.length > 1){
						ctx.lineWidth = 3;
						for(let i = 1; i < mousePosArr.length; i++){
							//ctx.strokeStyle = 'hsl(' + (i/mousePositions * 360) + ',50%,50%)';
							
							const grad = ctx.createLinearGradient(mousePosArr[0].x, mousePosArr[0].y, mousePosArr[i].x, mousePosArr[i].y);
							grad.addColorStop(0, 'rgba(255,255,255,0)');
							grad.addColorStop(0.5, 'hsl(' + (i/mousePosArr.length * 360) + ',90%,50%)');
							grad.addColorStop(1, 'rgba(255,255,255,0)');
							ctx.strokeStyle = grad;
							
							ctx.beginPath();
							ctx.moveTo(mousePosArr[0].x, mousePosArr[0].y);
							ctx.lineTo(mousePosArr[i].x, mousePosArr[i].y);
							ctx.stroke();
						}
						ctx.lineWidth = 1;
					}
					
					
					drawCircle(ctx, mousePoint, 5, 'red');
				}
			}
		}

		function playNote(frequency, time){
			const aCtx = new AudioContext(); 
			
			const gainNode = aCtx.createGain();
			gainNode.gain.value = 0.3;
			gainNode.connect(aCtx.destination);
			
			const distortion = aCtx.createWaveShaper();
			distortion.curve = makeDistortionCurve(50);
			//distortion.oversample = '4x';
			distortion.connect(gainNode)
			
			
			const osc = aCtx.createOscillator();
			osc.frequency.value = frequency;
			osc.type = 'sine';
			osc.connect(distortion);
			osc.start();
			osc.stop(aCtx.currentTime + time);
		}
		
		function pointReflect(origin, point, multiplier){
			const xDiff = origin.x - point.x;
			const yDiff = origin.y - point.y;

			const x = origin.x + xDiff * multiplier;
			const y = origin.y + yDiff * multiplier;
			return {x:x, y:y};
		}
		
		function pointByAngle(center, radius, angle){
			const x = Math.sin(angle) * radius + center.x;
			const y = Math.cos(angle) * radius + center.y;
			return {x:x, y:y};
		}
		
		function pointOnCircle(center, radius, totalPoints, pointNum){
			const angle = pointNum / totalPoints * Math.PI * 2;
			const x = Math.sin(angle) * radius + center.x;
			const y = Math.cos(angle) * radius + center.y;
			return {x:x, y:y};
		}

		function distance(p1, p2, signed){
			let xDiff;
			let yDiff;
			if(signed){
				xDiff = p2.x - p1.x;
				yDiff = p2.y - p1.y;
				
				console.log('X: ' + xDiff);
				console.log('Y:' + yDiff);
			}
			else{
				xDiff = Math.abs(p1.x - p2.x);
				yDiff = Math.abs(p1.y - p2.y);
			}

			let dist = Math.sqrt(xDiff * xDiff + yDiff * yDiff);
			if(xDiff > 0 && yDiff > 0)
				dist *= -1;
			return dist;
		}
		
		function midpoint(p1, p2){
			const x = (p1.x + p2.x) / 2;
			const y = (p1.y + p2.y) / 2;
			return {x:x, y:y};
		}
		
		function drawCircle(ctx, center, radius, color){
			ctx.fillStyle = color;
			
			ctx.beginPath();
			ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
			ctx.fill();
		}
		
		function angleOfC(a, b, c){
			const numerator = a * a + b * b - c * c;
			const deno = 2 * a * b;
			
			const arc = numerator / deno;
			
			return Math.acos(arc);
		}
		
		function perpendicular(p1, p2){
			const deltaX = p2.x - p1.x;
			const deltaY = p2.y - p1.y;
			
			const mid = midpoint(p1,p2);
			
			const start = {x: mid.x + deltaY/2, y: mid.y - deltaX/2};
			const end = {x: mid.x - deltaY/2, y: mid.y + deltaY/2};
			
			return {start: start, end: end};
		}
		
		window.addEventListener('DOMContentLoaded', () => {
			document.getElementById('startBtn').addEventListener('click', setUp);
			document.getElementById('stopDrawingBtn').addEventListener('click', () => {
				osc.stop();
				started = false;
				ctx.fillStyle = 'white';
				ctx.fillRect(0,0,w,w);
				document.getElementById('stopDrawingBtn').style.display = 'none';
				document.getElementById('startBtn').style.display = 'block';
			});
			//setUp();
			//drawPattern();
		});
	</script>
	
</head>
<body>
<div class="navHolder">
	<nav>
		<a href="../index.html">Home</a>
		<a class="selected" href="../ramblings.html">Deranged Ramblings</a>
		<a href="../about.html">About</a>
	</nav>
</div>

<main>
	<div class="pageWidth">
		<header>
			<h1>Digital Theramin</h1>
		</header>
		<section>
			<p>Y-Axix is volume, X-Axis is frequency</p>
			<p>Move mouse around on desktop. Tap areas on phone</p>
			<button id="startBtn">START</button>
			<button id="stopDrawingBtn" style="display:none">STOP</button>

			<div id="sizeCalc"></div>
			<img id="modMulResult">
			<div id="canvResult"></div>
		</section>
		<div class="scrollOverflow"></div>
	</div>
</main>
</body>
</html>